#!/usr/bin/env ruby

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])

require 'rubygems'
require 'rubygems/specification'
require 'sinatra'
require 'timeout'
require 'yaml'
require 'net/http'
require 'safegem/exception'
require 'json'
require 'base64'
require 'zlib'

post '/' do
  p params
  r, w = IO.pipe

  pid = nil
  begin
    repo     = params[:repo]
    data     = params[:data]
    callback = params[:callback]
    token    = params[:token]
    tmpdir   = "tmp/#{repo}"
    spec     = nil

    Timeout::timeout(300) do
      `git clone --depth 1 git://github.com/#{repo} #{tmpdir}`
      p "Cloned #{repo}"

      pid = fork do
        begin
          r.close

          require 'safegem/security'
          require 'safegem/lazy_dir'
          Dir.chdir(tmpdir) do
            thread = Thread.new do
              eval <<-EOE
                BEGIN { # First in first out. Get this one exec'ed before the code below.
                  Object.class_eval do
                    remove_const :OrigDir rescue nil
                    OrigDir = Dir
                    remove_const :Dir
                    Dir = LazyDir
                  end
                  $SAFE = 3
                  OrigDir.set_safe_level
                }
                BEGIN { # This forces Ruby to ignore nested END {} blocks
                  begin
                    params = tmpdir = data = spec = repo = nil
                    # Pass data out using TLS
                    Thread.current[:spec] = (#{data})
                  ensure
                    Object.class_eval do
                      remove_const :Dir
                      Dir = OrigDir
                    end
                  end
                }
              EOE
            end.join
            Dir.set_safe_level
            spec = thread[:spec]
            spec.rubygems_version = Gem::RubyGemsVersion # make sure validation passes
            spec.validate
          end

          payload = Base64.encode64(Zlib::Deflate.deflate(YAML.dump(spec)))
          p payload.size
          w.write payload
          w.close
        rescue Object
          puts $!, $@

          w.write "ERROR: #$!"
          w.close
        end
      end

      w.close
      p "Waiting for conversion"
      Process.wait(pid)
      yaml = r.read
      r.close

      p "Request build from GitHub"
      payload = {'token' => token, 'yaml' => yaml}
      res  = Net::HTTP.post_form(URI.parse(callback), payload)
      data = res.body
      p data

      p "Success"
      packet = {'result' => "Successfully converted #{repo} gemspec to YAML.", 'error' => nil}
      p packet
      packet.to_json
    end
  rescue Exception => e
    Process.kill(9, pid) rescue nil
    packet = {'error' => e.to_hash}
    p packet

    packet.to_json
  ensure
    `rm -rf #{tmpdir}` if tmpdir
  end
end